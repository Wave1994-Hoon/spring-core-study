## SOLID
#### SOLID 란?
- 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙 정리
    - SRP: 단일 책임 원칙 (single responsibility principle)
    - OCP: 개발-폐쇄 원칙 (open/closed principle)
    - LSP: 리스코프 치환 원칙 (Liskov substitution principle)
    - ISP: 인터페이스 분리 원칙 (Interface segregation principle)
    - DIP: 의존관계 역전 원칙 (Dependency inversion principle)
    
#### SRP 단일 책임 원칙
- 한 클래스는 하나의 책임만 가져야 한다.
- 하나의 책임이라는 것은 모호하다.
    - 클 수 있고, 작을 수 있다.
    - 문맥과 상황에 따라 다르다.
- 중요한 기준은 변경, 변경이 있을 때 파급 효과가 적으면 단익 책임 원칙을 잘 따른 것 

#### OCP 개발 폐쇄 원칙
- 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다..
- 확장을 하려면 ?? 당연히 기존 코드를 변경 ???
- 다형성을 살펴보면됨
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능 구현
- 지금까지 배운 역할과 구현의 분리를 참고 
- ** 문제점
    - 아래 예제에서 MemberService 클라이언트가 구현 클래스를 직접 선택
        - MemberRepository m = new MemoryMemberRepository(); // 기존 코드
        - MemberRepository m = new JdbcMemberRepository();   // 변경 코드
    - 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다. ---> OCP 원칙 꺠짐
    - 분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없음
    - 이 문제를 어떻게 해결 ????
    - 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자 필요 !!! ----> 스프링이 이걸 해줌 !!!
    
#### LSP 리스코프 치환 원칙 
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않음녀서 하위 타입의 인스턴스로 바꿀 수 있어야함
- 다형성에서 하위 클래스는 인터페이스 규악을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙
- 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요
- 본인의 역할에 충실해야함 ex) 자동차 엑셀 --> 앞으로 가기, 뒤로 가면 X 

#### ISP 인터페이스 분리 원칙
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- 자동차 인터페이스 -> 운전, 정비 인터페이스로 분리
- 사용자 클라이언트 -< 운전자, 정비사 클라이언트로 분리
- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향 주지 않음
- 인터페이스 명호가 !!, 대체 가능성 높아짐 !!!

#### DIP 의존관계 역전 원칙
- 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다" ???
- 의존성 주입은 이 원칙을 따르는 방법 중 하나이다.
- 쉽게 이야기해서 구현 클래스에 의존하지 말고, 역할(인터페이스)에 의존하라는 말임
- 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다. 
- 구현체에 의존하게 되면 변경이 어렵다.
- 그런데 OCP에서 설명한 MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존
    - MemberService 클라이언트가 구현 클래스를 직접 선택
    - MemberRepository m = new MemoryMemberRepository(); ---> DIP 위반 
    
#### 정리
- 객체 지향의 핵심은 다형성
- 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
- 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경
- 다형성 만으로는 OCP, DIP를 지킬 수 없다.
- 이 문제를 스프링이 해결해준다. 


#### 추가
- new 로 객체를 생성하면, 해당 클래스는 인터페이스에도 의존, new 객체도 의존하는 상태이다.
- 인터페이스에만 의존하도록 설계하기 위해서는 new 객체를 생성하지 않고 `private DiscountPolicy discountPolicy`만 사용하고 싶다.
- 하지만 이렇게 할 경우 해당 객체를 사용하게 된다면 null point exception 이 발생하게 된다.
- 따라서 누군가(Spring)이 구현 객체를 대신 생성하고 주입해줘야한다.


